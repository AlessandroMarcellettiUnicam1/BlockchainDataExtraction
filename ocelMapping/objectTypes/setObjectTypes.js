import {
    addContractAddressRelationships, addEventRelationships, addInputNameRelationships, addInternalTxRelationships,
    addSenderRelationships,
    addTxHashRelationships, addVariableRelationships
} from "./objRelationships/addRelationships.js";

export const handleContractAddressObjects = (jsonLog, ocel) => {

    const contractAddress = []

    jsonLog.forEach((log) => {
        contractAddress.push({
            time: log.timestamp,
            id: log.contractAddress + "_" + log.transactionHash,
            name: "contractAddress",
            value: log.contractAddress,
            type: "string"
        })
    })

    const newObjectTypes = [...ocel.objectTypes]
    const valuesSet = contractAddress.filter((value, index, self) => index === self.findIndex((t) => t.name === value.name))
    valuesSet.forEach(value => {
            newObjectTypes.push({
                name: value.name,
                attributes: [{name: "contractAddressValue", type: value.type}],
            })
        }
    )

    let objects = [...ocel.objects]
    contractAddress.forEach(value => {
        const attributeValues = [{name: "contractAddressValue", time: value.time, value: value.value}]
        const object = {
            id: value.id,
            type: value.name,
            attributes: attributeValues
        }

        objects.push(object)
    })

    const events = [...ocel.events]
    events.forEach((event) => {
        objects.forEach((object) => {
            if (object.type === "contractAddress" && object.id.split('_')[1] === event.id) {
                event.relationships.push({objectId: object.id, qualifier: "generated by"})
            }
        })
    })

    objects = addContractAddressRelationships(objects, jsonLog);

    return {
        events,
        objectTypes: newObjectTypes,
        objects
    }
}

export const handleTxHashObjects = (jsonLog, ocel) => {
    const txHashes = []

    jsonLog.forEach((log) => {
        txHashes.push({
            time: log.timestamp,
            id: log.transactionHash,
            name: "transactionHash",
            value: log.transactionHash,
            type: "string"
        })
    })

    let newObjectTypes = [...ocel.objectTypes]
    const valuesSet = txHashes.filter((value, index, self) => index === self.findIndex((t) => t.name === value.name))
    valuesSet.forEach(value => {
            newObjectTypes.push({
                name: value.name,
                attributes: [{name: "hashValue", type: value.type}]
            })
        }
    )

    let objects = [...ocel.objects]
    txHashes.forEach(value => {
        let attributeValues = []
        attributeValues = [{name: "hashValue", time: value.time, value: value.value}]

        objects.push({
            id: value.id,
            type: value.name,
            attributes: attributeValues
        })
    })

    const events = [...ocel.events]
    events.forEach((event) => {
        objects.forEach((object) => {
            if (object.type === "transactionHash" && object.id === event.id) {
                event.relationships.push({objectId: object.id, qualifier: "hash"})
            }
        })
    })

    objects = addTxHashRelationships(objects);

    return {
        events,
        objectTypes: newObjectTypes,
        objects
    }
}

export const handleSenderObjects = (jsonLog, ocel) => {
    const senders = []

    jsonLog.forEach((log) => {
        senders.push({
            time: log.timestamp,
            id: log.sender + "_" + log.transactionHash,
            name: "sender",
            value: log.sender,
            type: "string"
        })
    })

    let newObjectTypes = [...ocel.objectTypes]
    const valuesSet = senders.filter((value, index, self) => index === self.findIndex((t) => t.name === value.name))
    valuesSet.forEach(value => {
            newObjectTypes.push({
                name: value.name,
                attributes: [{name: "senderAddress", type: value.type}]
            })
        }
    )

    let objects = [...ocel.objects]
    senders.forEach(value => {
        let attributeValues = []
        attributeValues = [{name: "senderAddress", time: value.time, value: value.value}]

        objects.push({
            id: value.id,
            type: value.name,
            attributes: attributeValues
        })
    })

    const events = [...ocel.events]
    events.forEach((event) => {
        objects.forEach((object) => {
            if (object.type === "sender" && object.id.split('_')[1] === event.id) {
                event.relationships.push({objectId: object.id, qualifier: "sent by"})
            }
        })
    })

    objects = addSenderRelationships(objects);

    return {
        events,
        objectTypes: newObjectTypes,
        objects
    }
}

export const handleInputNameObjects = (jsonLog, ocel) => {
    const variables = []
    const idPrefix = "inputName_"

    jsonLog.forEach((log) => {
        log.inputs.forEach((input, index) => {
            variables.push({
                time: log.timestamp,
                id: idPrefix + index + "_" + log.transactionHash,
                name: input.inputName,
                value: input.inputValue,
                type: typeof input.inputValue === "number" ? "integer" : typeof input.inputValue
            })
        })
    })

    let newObjectTypes = [...ocel.objectTypes]
    const valuesSet = variables.filter((value, index, self) => index === self.findIndex((t) => t.name === value.name))
    valuesSet.forEach(value => {
            newObjectTypes.push({
                name: value.name,
                attributes: [{name: "inputValue", type: value.type}]
            })
        }
    )

    let objects = [...ocel.objects]
    variables.forEach(value => {
        let attributeValues = []
        attributeValues = [{name: "inputValue", time: value.time, value: value.value}]

        objects.push({
            id: value.id,
            type: value.name,
            attributes: attributeValues
        })
    })

    const events = [...ocel.events]
    events.forEach((event) => {
        objects.forEach((object) => {
            if (object.id.includes(idPrefix) && object.id.split("_")[2] === event.id) {
                event.relationships.push({objectId: object.id, qualifier: "takes"})
            }
        })
    })

    objects = addInputNameRelationships(objects);

    return {
        events,
        objectTypes: newObjectTypes,
        objects
    }
}

export const handleVariableNameObjects = (jsonLog, ocel) => {
    const variables = []
    const idPrefix = "variable_"

    jsonLog.forEach((log) => {
        log.storageState.forEach((variable) => {
            variables.push({
                time: log.timestamp,
                id: idPrefix + variable.variableName + "_" + log.contractAddress,
                name: variable.variableName,
                value: variable.variableValue,
                type: typeof variable.variableValue === "number" ? "integer" : typeof variable.variableValue
            })
        })
    })

    let newObjectTypes = [...ocel.objectTypes]
    let objects = [...ocel.objects]
    const valuesSet = variables.filter((value, index, self) => index === self.findIndex((t) => t.name === value.name))
    valuesSet.forEach(value => {
            newObjectTypes.push({
                name: value.name,
                attributes: [{name: "variableValue", type: value.type}]
            })
            const varObject = {
                id: value.id,
                type: value.name,
                attributes: []
            }
            variables.forEach(variable => {
                if (variable.name === value.name) {
                    varObject.attributes.push({name: "variableValue", time: variable.time, value: variable.value})
                }
            })
            objects.push(varObject)
        }
    )

    // variables.forEach(value => {
    //     let attributeValues = []
    //     attributeValues = [{name: "value", time: value.time, value: value.value}]
    //
    //     objects.push({
    //         id: value.id,
    //         key: "variableName",
    //         type: value.name,
    //         attributes: attributeValues
    //     })
    // })

    const events = [...ocel.events]
    events.forEach((event) => {
        objects.forEach((object) => {
            if (object.id.includes(idPrefix) && object.attributes.some(attribute => attribute.time === event.time)) {
                event.relationships.push({objectId: object.id, qualifier: "updates"})
            }
        })
    })

    objects = addVariableRelationships(objects, jsonLog);

    return {
        events,
        objectTypes: newObjectTypes,
        objects
    }
}

export const handleEventNameObjects = (jsonLog, ocel) => {
    const variables = []
    const idPrefix = "event_"

    jsonLog.forEach((log) => {
        log.events.forEach((event, index) => {

            const variable = {
                time: log.timestamp,
                id: idPrefix + index + "_" + log.transactionHash,
                name: event.eventName,
                attributes: [],
                attributesValue: []
            }

            const attributesNumber = event.eventValues.__length__
            for (let i = 0; i < attributesNumber; i++) {
                const attributeName = Object.keys(event.eventValues)[i + attributesNumber + 1] || Object.keys(event.eventValues)[i]
                variable.attributes.push({
                    name: attributeName,
                    type: typeof event.eventValues[Object.keys(event.eventValues)[i]] === "number" ? "integer" : "string"
                })

                variable.attributesValue.push({
                    name: attributeName,
                    time: log.timestamp,
                    value: event.eventValues[Object.keys(event.eventValues)[i]]
                })
            }
            variables.push(variable)

        })
    })

    let newObjectTypes = [...ocel.objectTypes]
    const valuesSet = variables.filter((value, index, self) => index === self.findIndex((t) => t.name === value.name))
    valuesSet.forEach(value => {
            newObjectTypes.push({
                name: value.name,
                attributes: value.attributes
            })
        }
    )

    let objects = [...ocel.objects]
    variables.forEach(value => {

        objects.push({
            id: value.id,
            type: value.name,
            attributes: value.attributesValue
        })
    })

    const events = [...ocel.events]
    events.forEach((event) => {
        objects.forEach((object) => {
            if (object.id.includes(idPrefix) && object.id.split("_")[2] === event.id) {
                event.relationships.push({objectId: object.id, qualifier: "emits"})
            }
        })
    })

    objects = addEventRelationships(objects);

    return {
        events,
        objectTypes: newObjectTypes,
        objects
    }
}

export const handleCallTypeObjects = (jsonLog, ocel) => {
    const variables = []
    const idPrefix = "internalTransaction_"

    jsonLog.forEach((log) => {
        log.internalTxs.forEach((internalTx, index) => {
            variables.push({
                time: log.timestamp,
                id: idPrefix + index + "_" + log.transactionHash,
                name: "internalTransaction",
                value: {"callType": internalTx.callType, "to": internalTx.to},
                type: "string"
            })
        })
    })

    let newObjectTypes = [...ocel.objectTypes]
    const valuesSet = variables.filter((value, index, self) => index === self.findIndex((t) => t.name === value.name))
    valuesSet.forEach(value => {
        newObjectTypes.push({
            name: value.name,
            attributes: [{name: "callType", type: "string"}, {name: "to", type: "string"}]
        })
    })

    let objects = [...ocel.objects]
    variables.forEach(value => {
        let attributeValues = []
        attributeValues = [{name: "callType", time: value.time, value: value.value.callType}, {name: "to", time: value.time, value: value.value.to}]

        objects.push({
            id: value.id,
            type: value.name,
            attributes: attributeValues
        })
    })

    const events = [...ocel.events]
    events.forEach((event) => {
        objects.forEach((object) => {
            if (object.id.includes(idPrefix) && object.id.split("_")[2] === event.id) {
                event.relationships.push({objectId: object.id, qualifier: "invokes"})
            }
        })
    })

    objects = addInternalTxRelationships(objects);

    return {
        events,
        objectTypes: newObjectTypes,
        objects
    }
}

// export const handleSelectEventsObjects = (jsonLog, ocel, setObjectsTypesItem, objectsTypesItem, objectType, setObjectsItem, setOcel) => {
//     const events = new Set()
//
//     jsonLog.forEach((log) => {
//         log.events.forEach((event) => {
//             events.add(event.eventName)
//         })
//     })
//
//     let newObjectTypes = [...ocel.objectTypes]
//     newObjectTypes.push({
//         name: "events",
//         attributes: Array.from(events).map((_, index) => ({name: `eventName_${index + 1}`, type: "string"}))
//     })
//
//     const objects = []
//     jsonLog.forEach((log, index) => {
//         const attributes = []
//         for (let i = 0; i < events.size; i++) {
//             let value = ""
//             if (i <= log.events.length - 1 && Array.from(events).includes(log.events[i].eventName)) {
//                 value = log.events[i].eventName
//             }
//
//             attributes.push({
//                 name: `eventName_${i + 1}`,
//                 time: log.timestamp,
//                 value: value
//             })
//         }
//
//         objects.push({
//             id: `event_${index + 1}`,
//             type: "events",
//             attributes: attributes
//         })
//     })
//
//     setObjectsTypesItem(objectsTypesItem.map(item => item === objectType ? {
//         ...item,
//         name: "events",
//         names: objects.map((object) => ({name: `events`, id: object.id}))
//     } : item))
//
//     setOcel({
//         ...ocel,
//         objectTypes: newObjectTypes,
//         objects: [...ocel.objects, ...objects],
//     })
//
//     const ocelEvents = [...ocel.events]
//     ocelEvents.forEach((event) => {
//         objects.forEach((object) => {
//             if (object.attributes[0]?.time === event.time) {
//                 event.relationships.push({objectId: object.id, qualifier: "emits"})
//             }
//         })
//     })
// }
//
// export const handleSelectInputsObjects = (jsonLog, ocel, setObjectsTypesItem, objectsTypesItem, objectType, setObjectsItem, setOcel) => {
//     const inputs = new Set()
//
//     jsonLog.forEach((log) => {
//         log.inputs.forEach((input) => {
//             inputs.add(input.inputName)
//         })
//     })
//
//     let newObjectTypes = [...ocel.objectTypes]
//     newObjectTypes.push({
//         name: "inputs",
//         attributes: Array.from(inputs).map((_, index) => ({name: `inputName_${index + 1}`, type: "string"}))
//     })
//
//     const objects = []
//     jsonLog.forEach((log, index) => {
//         const attributes = []
//         for (let i = 0; i < inputs.size; i++) {
//             let value = ""
//             if (i <= log.inputs.length - 1 && Array.from(inputs).includes(log.inputs[i].inputName)) {
//                 value = log.inputs[i].inputName
//             }
//
//             attributes.push({
//                 name: `inputName_${i + 1}`,
//                 time: log.timestamp,
//                 value: value
//             })
//         }
//
//         objects.push({
//             id: `input_${index + 1}`,
//             type: "inputs",
//             attributes: attributes
//         })
//     })
//
//     setObjectsTypesItem(objectsTypesItem.map(item => item === objectType ? {
//         ...item,
//         name: "inputs",
//         names: objects.map((object) => ({name: `inputs`, id: object.id}))
//     } : item))
//
//     setOcel({
//         ...ocel,
//         objectTypes: newObjectTypes,
//         objects: [...ocel.objects, ...objects],
//     })
//
//     const ocelEvents = [...ocel.events]
//     ocelEvents.forEach((event) => {
//         objects.forEach((object) => {
//             if (object.attributes[0]?.time === event.time) {
//                 event.relationships.push({objectId: object.id, qualifier: "takes"})
//             }
//         })
//     })
// }
//
// export const handleSelectInternalTxsObjects = (jsonLog, ocel, setObjectsTypesItem, objectsTypesItem, objectType, setObjectsItem, setOcel) => {
//     const internalTxs = new Set()
//     const internalTxsSize = new Set()
//
//     jsonLog.forEach((log) => {
//         log.internalTxs.forEach((internalTx, index) => {
//             internalTxs.add(internalTx.callType)
//             internalTxsSize.add(`internalTx_${index + 1}`)
//         })
//     })
//
//     let newObjectTypes = [...ocel.objectTypes]
//     newObjectTypes.push({
//         name: "internalTxs",
//         attributes: Array.from(internalTxsSize).map((_, index) => ({name: `internalTx_${index + 1}`, type: "string"}))
//     })
//
//     const objects = []
//     jsonLog.forEach((log, index) => {
//         const attributes = []
//         for (let i = 0; i < internalTxsSize.size; i++) {
//             let value = ""
//             if (i <= log.internalTxs.length - 1 && Array.from(internalTxs).includes(log.internalTxs[i].callType)) {
//                 value = log.internalTxs[i].callType
//             }
//
//             attributes.push({
//                 name: `internalTx_${i + 1}`,
//                 time: log.timestamp,
//                 value: value
//             })
//         }
//
//         objects.push({
//             id: `internalTx_${index + 1}`,
//             type: "internalTxs",
//             attributes: attributes
//         })
//     })
//
//     setObjectsTypesItem(objectsTypesItem.map(item => item === objectType ? {
//         ...item,
//         name: "internalTxs",
//         names: objects.map((object) => ({name: `internalTxs`, id: object.id}))
//     } : item))
//
//     setOcel({
//         ...ocel,
//         objectTypes: newObjectTypes,
//         objects: [...ocel.objects, ...objects],
//     })
//
//     const ocelEvents = [...ocel.events]
//     ocelEvents.forEach((event) => {
//         objects.forEach((object) => {
//             if (object.attributes[0]?.time === event.time) {
//                 event.relationships.push({objectId: object.id, qualifier: "invokes"})
//             }
//         })
//     })
// }
//
// export const handleSelectStorageStateObjects = (jsonLog, ocel, setObjectsTypesItem, objectsTypesItem, objectType, setObjectsItem, setOcel) => {
//     const variables = new Set()
//     const variableSize = new Set()
//
//     jsonLog.forEach((log) => {
//         log.storageState.forEach((variable, index) => {
//             variables.add(variable.variableName)
//             variableSize.add(`variableName_${index + 1}`)
//         })
//     })
//
//     let newObjectTypes = [...ocel.objectTypes]
//     newObjectTypes.push({
//         name: "storageState",
//         attributes: Array.from(variableSize).map((_, index) => ({name: `variableName_${index + 1}`, type: "string"}))
//     })
//
//     const objects = []
//     jsonLog.forEach((log, index) => {
//         const attributes = []
//         for (let i = 0; i < variableSize.size; i++) {
//             let value = ""
//             if (i <= log.storageState.length - 1 && Array.from(variables).includes(log.storageState[i].variableName)) {
//                 value = log.storageState[i].variableName
//             }
//
//             attributes.push({
//                 name: `variableName_${i + 1}`,
//                 time: log.timestamp,
//                 value: value
//             })
//         }
//
//         objects.push({
//             id: `storageStateVariable`,
//             type: "storageState",
//             attributes: attributes
//         })
//     })
//
//     setObjectsTypesItem(objectsTypesItem.map(item => item === objectType ? {
//         ...item,
//         name: "storageState",
//         names: objects.map((object) => ({name: `storageState`, id: object.id}))
//     } : item))
//
//     setOcel({
//         ...ocel,
//         objectTypes: newObjectTypes,
//         objects: [...ocel.objects, ...objects],
//     })
//
//     const ocelEvents = [...ocel.events]
//     ocelEvents.forEach((event) => {
//         objects.forEach((object) => {
//             if (object.attributes[0]?.time === event?.time) {
//                 event.relationships.push({objectId: object.id, qualifier: "updates"})
//             }
//         })
//     })
// }