const {
    addContractAddressRelationships, addEventRelationships, addInputNameRelationships, addInternalTxRelationships,
    addSenderRelationships,
    addTxHashRelationships, addVariableRelationships
} = require("./objRelationships/addRelationships.js");

const handleContractAddressObjects = (jsonLog, ocel) => {

    const contractAddress = []

    jsonLog.forEach((log) => {
        contractAddress.push({
            time: log.timestamp,
            id: log.contractAddress + "_" + log.transactionHash,
            name: "contractAddress",
            value: log.contractAddress,
            type: "string"
        })
    })

    const newObjectTypes = [...ocel.objectTypes]
    const valuesSet = contractAddress.filter((value, index, self) => index === self.findIndex((t) => t.name === value.name))
    valuesSet.forEach(value => {
            newObjectTypes.push({
                name: value.name,
                attributes: [{name: "contractAddressValue", type: value.type}],
            })
        }
    )

    let objects = [...ocel.objects]
    contractAddress.forEach(value => {
        const attributeValues = [{name: "contractAddressValue", time: value.time, value: value.value}]
        const object = {
            id: value.id,
            type: value.name,
            attributes: attributeValues
        }

        objects.push(object)
    })

    const events = [...ocel.events]
    events.forEach((event) => {
        objects.forEach((object) => {
            if (object.type === "contractAddress" && object.id.split('_')[1] === event.id) {
                event.relationships.push({objectId: object.id, qualifier: "generated by"})
            }
        })
    })

    objects = addContractAddressRelationships(objects, jsonLog);

    return {
        events,
        objectTypes: newObjectTypes,
        objects
    }
}

const handleTxHashObjects = (jsonLog, ocel) => {
    const txHashes = []

    jsonLog.forEach((log) => {
        txHashes.push({
            time: log.timestamp,
            id: log.transactionHash,
            name: "transactionHash",
            value: log.transactionHash,
            type: "string"
        })
    })

    let newObjectTypes = [...ocel.objectTypes]
    const valuesSet = txHashes.filter((value, index, self) => index === self.findIndex((t) => t.name === value.name))
    valuesSet.forEach(value => {
            newObjectTypes.push({
                name: value.name,
                attributes: [{name: "hashValue", type: value.type}]
            })
        }
    )

    let objects = [...ocel.objects]
    txHashes.forEach(value => {
        let attributeValues = []
        attributeValues = [{name: "hashValue", time: value.time, value: value.value}]

        objects.push({
            id: value.id,
            type: value.name,
            attributes: attributeValues
        })
    })

    const events = [...ocel.events]
    events.forEach((event) => {
        objects.forEach((object) => {
            if (object.type === "transactionHash" && object.id === event.id) {
                event.relationships.push({objectId: object.id, qualifier: "hash"})
            }
        })
    })

    objects = addTxHashRelationships(objects);

    return {
        events,
        objectTypes: newObjectTypes,
        objects
    }
}

const handleSenderObjects = (jsonLog, ocel) => {
    const senders = []

    jsonLog.forEach((log) => {
        senders.push({
            time: log.timestamp,
            id: log.sender + "_" + log.transactionHash,
            name: "sender",
            value: log.sender,
            type: "string"
        })
    })

    let newObjectTypes = [...ocel.objectTypes]
    const valuesSet = senders.filter((value, index, self) => index === self.findIndex((t) => t.name === value.name))
    valuesSet.forEach(value => {
            newObjectTypes.push({
                name: value.name,
                attributes: [{name: "senderAddress", type: value.type}]
            })
        }
    )

    let objects = [...ocel.objects]
    senders.forEach(value => {
        let attributeValues = []
        attributeValues = [{name: "senderAddress", time: value.time, value: value.value}]

        objects.push({
            id: value.id,
            type: value.name,
            attributes: attributeValues
        })
    })

    const events = [...ocel.events]
    events.forEach((event) => {
        objects.forEach((object) => {
            if (object.type === "sender" && object.id.split('_')[1] === event.id) {
                event.relationships.push({objectId: object.id, qualifier: "sent by"})
            }
        })
    })

    objects = addSenderRelationships(objects);

    return {
        events,
        objectTypes: newObjectTypes,
        objects
    }
}

const handleInputNameObjects = (jsonLog, ocel) => {
    const variables = []
    const idPrefix = "inputName_"

    jsonLog.forEach((log) => {
        log.inputs.forEach((input, index) => {
            variables.push({
                time: log.timestamp,
                id: idPrefix + index + "_" + log.transactionHash,
                name: input.inputName,
                value: input.inputValue,
                type: typeof input.inputValue === "number" ? "integer" : typeof input.inputValue
            })
        })
    })

    let newObjectTypes = [...ocel.objectTypes]
    const valuesSet = variables.filter((value, index, self) => index === self.findIndex((t) => t.name === value.name))
    valuesSet.forEach(value => {
            newObjectTypes.push({
                name: value.name,
                attributes: [{name: "inputValue", type: value.type}]
            })
        }
    )

    let objects = [...ocel.objects]
    variables.forEach(value => {
        let attributeValues = []
        attributeValues = [{name: "inputValue", time: value.time, value: value.value}]

        objects.push({
            id: value.id,
            type: value.name,
            attributes: attributeValues
        })
    })

    const events = [...ocel.events]
    events.forEach((event) => {
        objects.forEach((object) => {
            if (object.id.includes(idPrefix) && object.id.split("_")[2] === event.id) {
                event.relationships.push({objectId: object.id, qualifier: "takes"})
            }
        })
    })

    objects = addInputNameRelationships(objects);

    return {
        events,
        objectTypes: newObjectTypes,
        objects
    }
}

const handleVariableNameObjects = (jsonLog, ocel) => {
    const variables = []
    const idPrefix = "variable_"

    jsonLog.forEach((log) => {
        log.storageState.forEach((variable) => {
            variables.push({
                time: log.timestamp,
                id: idPrefix + variable.variableName + "_" + log.contractAddress,
                name: variable.variableName,
                value: variable.variableValue,
                type: typeof variable.variableValue === "number" ? "integer" : typeof variable.variableValue
            })
        })
    })

    let newObjectTypes = [...ocel.objectTypes]
    let objects = [...ocel.objects]
    const valuesSet = variables.filter((value, index, self) => index === self.findIndex((t) => t.name === value.name))
    valuesSet.forEach(value => {
            newObjectTypes.push({
                name: value.name,
                attributes: [{name: "variableValue", type: value.type}]
            })
            const varObject = {
                id: value.id,
                type: value.name,
                attributes: []
            }
            variables.forEach(variable => {
                if (variable.name === value.name) {
                    varObject.attributes.push({name: "variableValue", time: variable.time, value: variable.value})
                }
            })
            objects.push(varObject)
        }
    )

    // variables.forEach(value => {
    //     let attributeValues = []
    //     attributeValues = [{name: "value", time: value.time, value: value.value}]
    //
    //     objects.push({
    //         id: value.id,
    //         key: "variableName",
    //         type: value.name,
    //         attributes: attributeValues
    //     })
    // })

    const events = [...ocel.events]
    events.forEach((event) => {
        objects.forEach((object) => {
            if (object.id.includes(idPrefix) && object.attributes.some(attribute => attribute.time === event.time)) {
                event.relationships.push({objectId: object.id, qualifier: "updates"})
            }
        })
    })

    objects = addVariableRelationships(objects, jsonLog);

    return {
        events,
        objectTypes: newObjectTypes,
        objects
    }
}

const handleEventNameObjects = (jsonLog, ocel) => {
    const variables = []
    const idPrefix = "event_"

    jsonLog.forEach((log) => {
        log.events.forEach((event, index) => {

            const variable = {
                time: log.timestamp,
                id: idPrefix + index + "_" + log.transactionHash,
                name: event.eventName,
                attributes: [],
                attributesValue: []
            }

            const attributesNumber = event.eventValues.__length__
            for (let i = 0; i < attributesNumber; i++) {
                const attributeName = Object.keys(event.eventValues)[i + attributesNumber + 1] || Object.keys(event.eventValues)[i]
                variable.attributes.push({
                    name: attributeName,
                    type: typeof event.eventValues[Object.keys(event.eventValues)[i]] === "number" ? "integer" : "string"
                })

                variable.attributesValue.push({
                    name: attributeName,
                    time: log.timestamp,
                    value: event.eventValues[Object.keys(event.eventValues)[i]]
                })
            }
            variables.push(variable)

        })
    })

    let newObjectTypes = [...ocel.objectTypes]
    const valuesSet = variables.filter((value, index, self) => index === self.findIndex((t) => t.name === value.name))
    valuesSet.forEach(value => {
            newObjectTypes.push({
                name: value.name,
                attributes: value.attributes
            })
        }
    )

    let objects = [...ocel.objects]
    variables.forEach(value => {

        objects.push({
            id: value.id,
            type: value.name,
            attributes: value.attributesValue
        })
    })

    const events = [...ocel.events]
    events.forEach((event) => {
        objects.forEach((object) => {
            if (object.id.includes(idPrefix) && object.id.split("_")[2] === event.id) {
                event.relationships.push({objectId: object.id, qualifier: "emits"})
            }
        })
    })

    objects = addEventRelationships(objects);

    return {
        events,
        objectTypes: newObjectTypes,
        objects
    }
}

const handleCallTypeObjects = (jsonLog, ocel) => {
    const variables = []
    const idPrefix = "internalTransaction_"

    jsonLog.forEach((log) => {
        log.internalTxs.forEach((internalTx, index) => {
            variables.push({
                time: log.timestamp,
                id: idPrefix + index + "_" + log.transactionHash,
                name: "internalTransaction",
                value: {"callType": internalTx.callType, "to": internalTx.to},
                type: "string"
            })
        })
    })

    let newObjectTypes = [...ocel.objectTypes]
    const valuesSet = variables.filter((value, index, self) => index === self.findIndex((t) => t.name === value.name))
    valuesSet.forEach(value => {
        newObjectTypes.push({
            name: value.name,
            attributes: [{name: "callType", type: "string"}, {name: "to", type: "string"}]
        })
    })

    let objects = [...ocel.objects]
    variables.forEach(value => {
        let attributeValues = []
        attributeValues = [{name: "callType", time: value.time, value: value.value.callType}, {name: "to", time: value.time, value: value.value.to}]

        objects.push({
            id: value.id,
            type: value.name,
            attributes: attributeValues
        })
    })

    const events = [...ocel.events]
    events.forEach((event) => {
        objects.forEach((object) => {
            if (object.id.includes(idPrefix) && object.id.split("_")[2] === event.id) {
                event.relationships.push({objectId: object.id, qualifier: "invokes"})
            }
        })
    })

    objects = addInternalTxRelationships(objects);

    return {
        events,
        objectTypes: newObjectTypes,
        objects
    }
}
module.exports={
    handleContractAddressObjects,
    handleTxHashObjects,
    handleSenderObjects,
    handleInputNameObjects,
    handleVariableNameObjects,
    handleEventNameObjects,
    handleCallTypeObjects,
}   